## 双指针问题

#### 1. 有序数组Two Sum

[LeetCode 167. Two Sum II - Input arrray is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

分析：设置left，right两个指针，分别指向数组的最左边和最右边元素。while循环，循环条件为left<right. 如果对应元素和小于目标，那么left+=1，如果大于目标right-=1.等于目标那么left、right为所求结果。退出循环，返回结果即可。

```python
# Python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers)-1
        while left < right:
            tmp = numbers[left] + numbers[right]
            if tmp < target:
                left += 1
            elif tmp > target:
                right -= 1
            else:
                res = [left+1, right+1]
                break
        return res

# c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size()-1;
        vector<int> ret;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum < target)
                left++;
            else if (sum > target)
                right--;
            else {
                ret.push_back(++left);
                ret.push_back(++right);
                break;
            }
        }
        return ret;
    }
};
```

#### 2. 两个整数的平方和

[LeetCode 633. Sum of Square Numbers (Easy)](https://leetcode.com/problems/sum-of-square-numbers/submissions/)

本题与问题1具有相同计算流程，区别在于target变为了两数平方和。

Note：这里可以将right直接初始化为$\sqrt {c}$。根据根号大小的性质可以减少不必要的操作。

```python
# Python
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        left, right = 0, int(math.sqrt(c))
        while left <= right:
            if left * left + right * right < c:
                left += 1
            elif left * left + right * right > c:
                right -= 1
            else:
                return True
        return False

# C++
class Solution {
public:
    bool judgeSquareSum(int c) {
        long int left = 0, right = sqrt(c);
        while (left <= right) {
            if (left * left + right * right < c)
                left++;
            else if (left * left + right * right > c)
                right--;
            else {
                return true;
            }
        }
        return false;
    }
};
```

#### 3. 翻转字符串中的元音字符

[LeetCode 345. Reverse Vowels of a String (Easy)](https://leetcode.com/problems/reverse-vowels-of-a-string/)

依然使用的是双指针从两边到中间的收缩过程。当left和right都指向一个元音字符的时候进行交换操作即可。

```python
# Python
class Solution:
    def reverseVowels(self, s: str) -> str:
        left, right = 0, len(s)-1
        mySet = ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        res = list(s)
        
        while left < right:
            if not res[left] in mySet:
                left += 1
            if not res[right] in mySet:
                right -= 1
            if res[left] in mySet and res[right] in mySet:
                tmp = res[left]
                res[left] = res[right]
                res[right] = tmp
                left += 1
                right -= 1
        return ''.join(res)
    
# C++
# 目前对C++的STL还不是很熟悉，这可能不是最好的方法。还有一种思路是直接使用数组存储，判断
# 的时候只要判断字符ASCII值对应索引即可。
class Solution {
public:
    string reverseVowels(string s) {
        int left = 0, right = s.size()-1;
        map<char, char> myMap = {{'a', 1}, {'e', 1}, {'i', 1}, {'o', 1}, {'u', 1}, {'A', 1}, {'E', 1}, {'I', 1}, {'O', 1}, {'U', 1}};
        
        while (left < right) {
            map<char, char>::iterator findLeft = myMap.find(s[left]);
            map<char, char>::iterator findRight = myMap.find(s[right]);
            if (findLeft == myMap.end())
                left++;
            if (findRight == myMap.end())
                right--;
            if (findLeft != myMap.end() && findRight != myMap.end()) {
                char tmp = s[left];
                s[left] = s[right];
                s[right] = tmp;
                left++;
                right--;
            }
        }
        return s;
    }
};
```

