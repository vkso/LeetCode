## 二分查找

#### 1. 求开方

[LeetCode 69. Sqrt(x) (Easy)](https://leetcode.com/problems/sqrtx/description/)

思路：while循环条件为`left <= right`，一般情况思路很清晰，这里主要主要边界情况。当while退出循环的时候，一定有`left > right`,以8为例子，此时left为3，right为2，应当返回right。（边界情况，往往是二分查找需要注意的地方）

```python
# Python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1: return x
        
        left, right = 1, x
        
        while left <= right:
            mid = (left + right) // 2
            if mid ** 2 > x:
                right = mid - 1
            elif mid ** 2 < x:
                left = mid + 1
            else:
                return mid
        return right
    
# C++
class Solution {
public:
    int mySqrt(int x) {
        if (x <= 1) return x;
        long int left = 1, right = x;
        while (left <= right) {
            long int mid = (left + right) / 2;
            if (mid * mid > x)
                right = mid - 1;
            else if (mid * mid < x)
                left = mid + 1;
            else
                return mid;
        }
        return right;
    }
};
```

#### 2. 大于给定元素的最小元素

[LeetCode 744. Find Smallest Letter Greater Than Target (Easy)](https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/)

方法一：直接比较，时间复杂度$O(n)$

方法二：二分搜索，时间复杂度$O(\log n)$

```python
# Python
# 方法一
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        if letters[-1] <= target: return letters[0]
        
        for item in letters:
            if item > target:
                return item
# 方法二
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        if letters[-1] <= target: return letters[0]
        
        left, right = 0, len(letters) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if letters[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        return letters[left]
    
# C++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        if (letters[letters.size()-1] <= target) return letters[0];
        
        int left = 0, right = letters.size() - 1;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            if (letters[mid] > target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return letters[left];
    }
};
```

