## 栈和队列

#### 1. 用栈实现队列

[LeetCode 232. Implement Queue using Stacks (Easy)](https://leetcode.com/problems/implement-queue-using-stacks/)

栈和队列是两种顺序完全相反的数据结构。队列先进先出（First In First Out）,栈先进后出（First In Last Out）。可以通过使用两个栈，数据在两个栈之间来回“倒腾”，实现队列的功能。

```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack1 = []
        self.stack2 = []
        

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        self.stack1.append(x)
        while self.stack1:
            self.stack2.append(self.stack1.pop())

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        return self.stack2.pop()
        

    def peek(self) -> int:
        """
        Get the front element.
        """
        return self.stack2[-1]
        

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        if len(self.stack2) == 0:
            return True
        else:
            return False
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```

#### 2. 用队列实现栈

与上面问题实现方法相同。后来的元素进队之前，把队中的元素全部转移到另一个队中，让新来的元素先进队。然后再把数据转移回来。

```python
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue1 = []
        self.queue2 = []
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        while self.queue2:
            self.queue1.append(self.queue2[0])
            del self.queue2[0]
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1[0])
            del self.queue1[0]
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        ret = self.queue2[0]
        del self.queue2[0]
        return ret
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue2[0]
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        if len(self.queue2) == 0:
            return True
        else:
            return False
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```



#### 3. 最小值栈

#### 4. 用栈实现括号匹配

#### 5. 数组中元素与下一个比它大的元素之间的距离

#### 6. 循环数组中比当前元素大的下一个元素

