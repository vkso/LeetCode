## æ•°ç»„ä¸çŸ©é˜µ

#### 1. æŠŠæ•°ç»„ä¸­çš„0ç§»åŠ¨åˆ°æœ«å°¾

[LeetCode 283. Move Zeros (Easy)](https://leetcode.com/problems/move-zeroes/description/)

è®¾ç½®ä¸€ä¸ªç´¢å¼•notZeroPointï¼Œå¼€å§‹æŒ‡å‘åˆ—è¡¨çš„å¼€å¤´ä½ç½®ã€‚æˆ‘ä»¬éå†æ•°ç»„ï¼Œå¯»æ‰¾é0å…ƒç´ ï¼Œå°†é0å…ƒç´ æŒ‰é¡ºåºä¾æ¬¡è®°å½•åœ¨ç´¢å¼•notZeroPointä¸­ã€‚éå†ç»“æŸåï¼Œæ‰€æœ‰çš„é0å…ƒç´ éƒ½æŒ‰å…ƒé¡ºåºæ’åˆ—åœ¨äº†åˆ—è¡¨çš„å‰é¢ã€‚å‰©ä¸‹å°†åé¢ä½ç½®è¡¥0å³å¯ã€‚

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        notZeroPoint = 0
        
        for item in nums:
            if item != 0:
                nums[notZeroPoint] = item
                notZeroPoint += 1
                
        while notZeroPoint < len(nums):
            nums[notZeroPoint] = 0
            notZeroPoint += 1
```

#### 2. æ”¹å˜çŸ©é˜µç»´åº¦

[LeetCode 566. Reshape the Matrix (Easy)](https://leetcode.com/problems/reshape-the-matrix/description/)

é¦–å…ˆåˆ¤æ–­çŸ©é˜µè¾“å…¥å…ƒç´ æ•°é‡æ˜¯å¦å¯ä»¥ç”Ÿæˆæ–°çš„çŸ©é˜µç»´åº¦ï¼Œå¦‚æœä¸èƒ½ç›´æ¥è¿”å›åŸçŸ©é˜µã€‚æ¥ä¸‹æ¥å°±åŒå±‚å¾ªç¯ï¼Œä¾æ¬¡æ·»åŠ åˆ°æ–°çš„åˆ—è¡¨ä¸­å³å¯ï¼ˆä¸­é—´è®¾ç½®iå˜é‡ç»Ÿè®¡æ¯è¡Œçš„åˆ—æ•°ã€‚ï¼‰æ—¶é—´å¤æ‚åº¦ä¸º$O(m*n)$

```python
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        old_r = len(nums)
        old_c = len(nums[0])
        ret, i, temp_row = [], 0, []
        
        if old_r * old_c != r * c:
            return nums
        
        for x in nums:
            for y in x:
                temp_row.append(y)
                i += 1
                if i % c == 0:
                    ret.append(temp_row)
                    temp_row = []
        return ret
```

#### 3. æ•°ç»„ä¸­æœ€é•¿çš„è¿ç»­1

[LeetCode 485. Max Consecutive Ones (Easy)](https://leetcode.com/problems/max-consecutive-ones/description/)

ç›´æ¥éå†åˆ—è¡¨ï¼Œå¦‚æœé‡åˆ°0ç›´æ¥é‡ç½®å½“å‰tmpLençš„é•¿åº¦ä¸º0.å¦‚æœé‡åˆ°1ï¼Œé‚£ä¹ˆå¯¹tmpLenè¿›è¡ŒåŠ 1æ“ä½œã€‚å¦‚æœå½“å‰å€¼æ¯”æœ€å¤§å€¼è¦å¤§ï¼Œé‚£ä¹ˆæ›´æ–°æœ€å¤§å€¼ã€‚

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        maxLen, tmpLen = 0, 0
        
        for index in range(len(nums)):
            if nums[index] == 1:
                tmpLen += 1
                if tmpLen > maxLen: maxLen = tmpLen
            else:
                tmpLen = 0
                
        return maxLen
```

#### 4. æœ‰åºçŸ©é˜µæŸ¥æ‰¾

[LeetCode 240. Search a 2D Matrix II (Medium)](https://leetcode.com/problems/search-a-2d-matrix-ii/description/)

ä»ç¬¬ä¸€è¡Œçš„æœ«å°¾å¼€å§‹å‘ä¸‹æœç´¢ï¼Œå¦‚æœå½“å‰å€¼æ¯”targetå°ï¼Œé‚£ä¹ˆå¯»æ‰¾ä¸‹ä¸€è¡Œã€‚å¦‚æœå½“å‰ä¸targetç›¸ç­‰ï¼Œè¿”å›Trueï¼Œå¦‚æœå½“å‰å€¼æ¯”targetå¤§ï¼Œé‚£ä¹ˆå¯»æ‰¾å‰ä¸€åˆ—çš„å€¼ã€‚

æœ¬é¢˜å¦‚æœæ˜¯ä»å·¦å‘å³æœç´¢çš„è¯ï¼Œéœ€è¦å¢åŠ è®¸å¤šåˆ¤æ–­æ¡ä»¶ã€‚å› ä¸ºä»å³å‘å·¦æœç´¢ï¼Œåˆ¤æ–­ç›®æ ‡æ¯”å½“å‰å€¼å°ï¼Œé‚£ä¹ˆæœç´¢å…¶ä¸‹ä¸€è¡Œå€¼ï¼Œç›®æ ‡æ¯”å½“å‰å€¼å¤§ï¼Œé‚£ä¹ˆæœç´¢å…¶å·¦åˆ—å€¼ï¼›è‹¥ä»å·¦å‘å³æœç´¢ï¼Œç›®æ ‡æ¯”å½“å‰å€¼å¤§ï¼Œä½†æ˜¯å½“å‰å…ƒç´ ğŸ‘‰å³è¾¹å’ŒğŸ‘‡ä¸‹é¢å€¼éƒ½æœ‰å¯èƒ½å­˜åœ¨ï¼Œéœ€è¦åˆ¤æ–­æœç´¢çš„èµ°å‘ã€‚

```python
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix or len(matrix) == 0 or len(matrix[0]) == 0: return False
        row_len = len(matrix)
        col_len = len(matrix[0])
        row, col = 0, col_len-1
        
        while row < row_len and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                col -= 1
            else:
                row += 1
        return False
```

#### 5. æœ‰åºçŸ©é˜µæŸ¥æ‰¾ç¬¬Kå°çš„å…ƒç´ 

[LeetCode 378. Kth Smallest Element in a Sorted Matrix (Medium)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

æ–¹æ³•ä¸€ï¼šï¼ˆæš´åŠ›æ’åºï¼‰

å¦‚æœä½¿ç”¨å†…ç½®å‡½æ•°å°†matrixè½¬æ¢ä¸º1ç»´åˆ—è¡¨ï¼Œå¯¹åˆ—è¡¨æ’åºï¼Œå»ç¬¬kä¸ªå€¼å³å¯ã€‚æ­¤æ–¹æ³•æ—¶é—´å¤æ‚åº¦å–å†³äºæ’åºç®—æ³•ã€‚

æ–¹æ³•äºŒï¼šäºŒåˆ†æŸ¥æ‰¾

ç”±äºçŸ©é˜µå¹¶ä¸æ˜¯çœŸæ­£çš„å•è°ƒåºåˆ—ï¼Œä¸å¯ä»¥ç›´æ¥ä½¿ç”¨äºŒåˆ†æœç´¢ã€‚ä½†æ˜¯è¯¥é—®é¢˜å¯ä»¥åˆ©ç”¨äºŒåˆ†æœç´¢çš„æ€æƒ³ã€‚è¯¥æ•°ç»„ä¸€å®šæœ‰æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œåˆ†åˆ«åœ¨æ•°ç»„çš„å·¦ä¸Šè§’å’Œå³ä¸‹è§’ã€‚é‚£ä¹ˆæˆ‘ä»¬è¦æ‰¾çš„æ•°ä¸€å®šæ˜¯ä»–ä»¬ä¹‹é—´çš„ä¸€ä¸ªæ•°ã€‚å‡è®¾ä»–ä»¬ä¹‹é—´æ˜¯é€’å¢çš„åºåˆ—ï¼Œé‚£ä¹ˆä¸€å®šå¯ä»¥ä½¿ç”¨äºŒåˆ†æœç´¢æ‰¾åˆ°è¿™ä¸ªå€¼ã€‚è®¾ç½®left, right, midä¸‰ä¸ªå˜é‡ï¼ŒäºŒåˆ†æœç´¢leftã€rightä¸æ–­é€¼è¿‘midã€‚midå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆã€‚

å¦‚ä¸‹å›¾ä¾‹å­æ‰€ç¤ºï¼Œleft = 1, right = 15, mid = (left + right) // 2 = 8ã€‚æˆ‘ä»¬åœ¨çŸ©é˜µä¸­ç»Ÿè®¡æ¯”midå°çš„æ•°çš„æ•°é‡countï¼Œå¦‚æœcountæ•°é‡å°äºkï¼Œé‚£ä¹ˆæ„å‘³ç€ï¼Œmidåå°äº†ï¼Œä¸è¶³ä»¥è¦†ç›–kä¸ªæ¯”ä»–å°çš„å€¼ï¼Œæ¢è€Œè¨€ä¹‹midä¸æ˜¯ç¬¬kå°çš„æ•°ã€‚æˆ‘ä»¬å¯»æ‰¾çš„midä¸€å®šåœ¨å³è¾¹ã€‚ä¸ºäº†å°†midå˜å¤§ï¼Œè¿™æ—¶å€™å°†leftç§»åŠ¨åˆ°mid+1çš„ä½ç½®ã€‚åŒç†ï¼Œå¦‚æœcountæ•°é‡å¤§äºç­‰äºkï¼Œæ„å‘³ç€midåå¤§äº†ï¼Œè¿™æ—¶å€™å°†rightç§»åŠ¨åˆ°midçš„ä½ç½®ã€‚å¾ªç¯ç»ˆæ­¢æ¡ä»¶æ˜¯left>rightçš„æ—¶å€™ã€‚é‚£ä¹ˆæ­¤æ—¶rightå°±æ˜¯æˆ‘ä»¬è¦å¯»æ‰¾çš„å€¼ã€‚

![example](./images/6-1.png)

```python
# æ–¹æ³•ä¸€
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        return sorted(sum(matrix,[]))[k-1]
    
# æ–¹æ³•äºŒ
# Runtime: 160ms
# Memory Usage: 19.7 MB
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        row = len(matrix)
        col = len(matrix[0])
        left, right = matrix[0][0], matrix[row-1][col-1]
        
        while left < right:
            mid = (left + right) // 2
            count = self.findNotBiggerThanMid(matrix, mid, row, col)
            if count < k:
                left = mid + 1
            else:
                right = mid
        return right
    # ä»å·¦ä¸‹è§’å…ƒç´ å¼€å§‹ç»Ÿè®¡æ¯”midå°çš„å…ƒç´ æ•°é‡
    def findNotBiggerThanMid(self, matrix, mid, row, col):
        i, j, count = row - 1, 0, 0
        while i >= 0 and j < col:
            if matrix[i][j]  <= mid:
                count += i + 1
                j += 1
            else:
                i -= 1
        return count
```

#### 6. æ•°ç»„ä¸­å¯»æ‰¾é‡å¤æ•°å’Œä¸¢å¤±æ•°

[LeetCode 645. Set Mismatch (Easy)](https://leetcode.com/problems/set-mismatch/description/)

æ–¹æ³•ä¸€ï¼šæ’åºæ•°ç»„

ç”±äºåˆ—è¡¨å†…çš„æ•°æ®æ˜¯ä¹±åºçš„ï¼Œä¸”åªæœ‰ä¸€ä¸ªæ•°æ®æ˜¯é‡å¤çš„ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡äº¤æ¢æ•°æ®çš„æ–¹å¼å°†åˆ—è¡¨ä¸­çš„æ•°æ®äº¤æ¢åˆ°å…¶æ­£ç¡®çš„ä½ç½®ä¸Šå»ã€‚é‚£ä¹ˆæœ€ç»ˆä¸€å®šæœ‰ä¸€ä¸ªæ•°å­—ä¸åœ¨è‡ªå·±çš„æ­£ç¡®ä½ç½®ä¸Šå¦‚ä¸‹ä¾‹å­æ‰€ç¤ºï¼š

```python
 input: [9, 7, 3, 2, 1, 5, 4, 6, 4]
output: [1, 2, 3, 4, 5, 6, 7, 4, 9]
```

å¯¹outputè¿›è¡Œéå†ï¼Œåˆ¤æ–­å½“å‰ç´¢å¼•ä½ç½®æ˜¯å¦æ˜¯æ­£ç¡®æ•°å­—ï¼Œå¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆè¿”å›ç´¢å¼•å€¼ä¸å½“å‰å€¼å³å¯ã€‚

éœ€è¦æ·±åˆ»ç†è§£çš„æ˜¯whileå¾ªç¯çš„åˆ¤æ–­æ¡ä»¶ï¼šå½“å‰ç´¢å¼•ä½ç½®çš„å€¼ï¼ˆå‡è®¾iä¸º0ï¼Œç´¢å¼•0å¯¹åº”çš„å€¼æ˜¯9ï¼‰ï¼Œä¸æ˜¯å¯¹åº”å€¼ï¼ˆ0å¯¹åº”çš„å€¼åº”è¯¥æ˜¯1ï¼‰ **å¹¶ä¸”** å½“å‰ä½ç½®çš„å€¼å‡å»1å¯¹åº”çš„ç´¢å¼•å€¼ä¸åˆç†ï¼ˆ9-1=8ï¼Œç´¢å¼•8å¯¹åº”çš„å€¼åº”è¯¥æ˜¯9ï¼Œä½†æ˜¯ç´¢å¼•8å¯¹åº”çš„å€¼ä¸º4ï¼‰ï¼Œé‚£ä¹ˆå¯¹è¿™ä¸¤å¤„çš„ç´¢å¼•å€¼äº¤æ¢ï¼Œä¸€å®šä¼šç ´åandä¸­çš„ä¸€ä¸ªæ¡ä»¶ï¼

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            while nums[i] != i + 1 and nums[nums[i]-1] != nums[i]:
                self.swap(nums, i, nums[i]-1)
            
        for i in range(len(nums)):
            if nums[i] != i + 1:
                return [nums[i], i + 1]
        return []
        
    def swap(self, nums, i, j):
        nums[i], nums[j] = nums[j], nums[i]
```

æ–¹æ³•äºŒï¼šä½¿ç”¨å­—å…¸

ä½¿ç”¨å­—å…¸åˆ¤æ–­è¯¥æ•°å­—æ˜¯å¦å‡ºç°ï¼Œå¦‚æœè¯¥æ•°å·²ç»å‡ºç°ï¼Œé‚£ä¹ˆä»–ä¸€å®šæ˜¯å“ªä¸ªé‡å¤çš„ã€‚æœ€åforå¾ªç¯éå†`1 : n`å…¨ä½“ï¼Œå¦‚æœåœ¨å­—å…¸ä¸­æ²¡å‡ºç°ï¼Œé‚£ä¹ˆä»–å°±æ˜¯ç¡®å®çš„é‚£ä¸ªã€‚æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œä»£ç å°±ä¸ç»™å‡ºäº†ã€‚

#### 7. æ‰¾å‡ºæ•°ç»„ä¸­é‡å¤çš„æ•°

[LeetCode 287. Find the Duplicate Number (Medium)](https://leetcode.com/problems/find-the-duplicate-number/description/)

æœ¬é¢˜å¦‚æœèƒ½ä½¿ç”¨å“ˆå¸Œè¡¨å°±éå¸¸å®¹æ˜“äº†ã€‚

æœ¬é¢˜çš„é™åˆ¶æ¡ä»¶å¦‚ä¸‹ï¼š

- ç»™å®šnumsåªè¯»
- ç©ºé—´å¤æ‚åº¦è¦æ±‚$O(1)$ ï¼ˆå‰ä¸¤æ¡é™åˆ¶ä¸èƒ½ä½¿ç”¨æ’åºç®—æ³•ï¼‰
- æ—¶é—´å¤æ‚åº¦å°äº$O(n^2)$
- åªæœ‰ä¸€ä¸ªæ•°æ˜¯é‡å¤çš„ï¼Œä½†æ˜¯ä»–å¯èƒ½å‡ºç°å¤šæ¬¡

**æ–¹æ³•ä¸€**ï¼ˆäºŒåˆ†æœç´¢ï¼‰

æœ¬é¢˜ä½¿ç”¨Binary Searchï¼Œæ–¹æ³•è·Ÿ**ç¬¬äº”é¢˜**æ˜¯ä¸€æ ·çš„ã€‚**äºŒåˆ†æ³•ä¸€å…±æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ä¸ªæ˜¯ç´¢å¼•äºŒåˆ†ï¼Œä¸€ä¸ªæ˜¯å€¼äºŒåˆ†ã€‚**

åˆ†æï¼š

`1, ... , mid-1, mid, mid+1, ... , 99`: å‡è®¾nç­‰äº99ã€‚é‚£ä¹ˆæ•°ç»„ä¸­å«æœ‰100ä¸ªæ•°ï¼Œä¸€å®šè‡³å°‘æœ‰ä¸€ä¸ªæ˜¯é‡å¤çš„ã€‚æˆ‘ä»¬æ±‚å‡ºmidï¼Œå¹¶ç»Ÿè®¡æ•´ä¸ªæ•°ç»„ä¸­å°äºmidå…ƒç´ çš„ä¸ªæ•°ã€‚

å¦‚æœä¸å­˜åœ¨é‡å¤å…ƒç´ ï¼Œé‚£ä¹ˆå°äºmidå…ƒç´ çš„ä¸ªæ•°ä¸€å®šä¸ä¼šè¶…è¿‡midä¸ªã€‚â‘ å¦‚æœæ²¡æœ‰è¶…è¿‡ï¼Œé‚£ä¹ˆè¯æ˜midåå°äº†ï¼Œé‡å¤çš„å€¼å¯èƒ½æ¯”midå¤§ï¼Œæ­¤æ—¶leftçš„å€¼åº”è¯¥å˜ä¸º`mid + 1`ã€‚â‘¡å¦‚æœè¶…è¿‡äº†ï¼Œé‚£ä¹ˆè¯´æ˜é‡å¤çš„å€¼ä¸€å®šæ¯”midå°ã€‚æˆ‘ä»¬åº”è¯¥ä½¿midå‡å°ï¼Œæ­¤æ—¶rightçš„å€¼å˜ä¸º`mid - 1 `ã€‚

å¦‚æ­¤å¾ªç¯ï¼Œæœ€ç»ˆå¾ªç¯ç»“æŸã€‚

**æ–¹æ³•äºŒ**ï¼ˆåŒæŒ‡é’ˆï¼Œå¿«æ…¢æŒ‡é’ˆï¼‰

è¯¥é—®é¢˜å¯ä»¥æŠ½è±¡æˆä¸€ä¸ªé“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯çš„é—®é¢˜ã€‚å› ä¸ºé•¿åº¦ä¸ºn+1çš„æ•°ç»„ï¼Œåªå­˜å‚¨äº†nä¸ªæ•°ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨é‡å¤çš„æ•°ã€‚å¦‚æœæ•°ç»„ä¸­æ¯ä¸ªç´¢å¼•ä¸­å­˜å‚¨çš„å€¼ä¸ºå…¶ä¸‹ä¸€ä¸ªç´¢å¼•åºå·ï¼Œé‚£ä¹ˆä¸€å®šå¯ä»¥å½¢æˆä¸€ä¸ªé—­åˆç¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![example](./images/6-2.png)

è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªå¿«ä¸€ä¸ªæ…¢ã€‚å¿«çš„æ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢çš„æ¯æ¬¡èµ°ä¸€æ­¥ã€‚ä»–ä»¬ä¸€å®šä¼šç›¸é‡ï¼Œå‡è®¾ç›¸é‡åœ¨Qç‚¹ï¼ˆå¯ä»¥é‡‡ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜ï¼‰ã€‚fastèµ°è¿‡çš„é•¿åº¦æœ‰`a + b + c + b`ï¼Œslowèµ°è¿‡çš„é•¿åº¦æœ‰`a + b`. ä»–ä»¬ç”±äºæ¯æ¬¡å¾ªç¯ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ã€‚é‚£ä¹ˆæœ‰$2\times(a+b)=a+b+c+b$ï¼Œå¯ä»¥å¾—åˆ°$a=c$. æ­¤æ—¶å°†fasté‡æ–°æŒ‡å‘å¼€å§‹ï¼Œé‚£ä¹ˆä»–ä»¬ç›¸é‡çš„æ—¶å€™å°±æ˜¯é—­ç¯å¼€å§‹çš„åœ°æ–¹Pã€‚Pä¸€å®šæ˜¯é‚£ä¸ªé‡å¤çš„æ•°ã€‚

```python
# python æ–¹æ³•ä¸€
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        left, right = 1, len(nums)-1
        # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        while left <= right:
            mid = (left + right) // 2
            count = 0
            for i in range(len(nums)):
                if nums[i] <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left
# C++ æ–¹æ³•ä¸€
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int left = 1, right = nums.size()-1;
        while (left <= right) {
            int mid = (left + right) / 2;
            int count = 0;
            for (int i=0; i < nums.size(); i++) {
                if (nums[i] <= mid)
                    count++;
            }
            if (count > mid)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return left;
    }
};

# æ–¹æ³•äºŒ python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        
        fast = 0
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
            
        return slow
# C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0];
        int fast = nums[slow];
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = 0;
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```

#### 8. ç¾ä¸½æ’åˆ—æ•°ç»„ï¼ˆäºŒï¼‰

[LeetCode 667. Beautiful Arrangement II (Medium)](https://leetcode.com/problems/beautiful-arrangement-ii/description/)

æœ¬é¢˜å°šæœªå‘ç°æŠ€å·§ï¼Œæ€»ç»“å‡ºæ’åˆ—è§„å¾‹å³å¯ã€‚

æ€»ç»“å½’çº³å‡ºå‰kä¸ªæ•°çš„è§„å¾‹`1, 1+k, 2, k, 3, k-1, ..., 1+(k+1)/2,..., 2+k, 3+k, ...`ï¼Œåé¢ç›´æ¥æ’å…¥æ’å€¼ä¸º1çš„é€’å¢åºåˆ—å³å¯

```python
# Python
class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        res = [1]
        for i in range(k):
            if i % 2 == 0:
                res.append(1 + k - i / 2)
            else:
                res.append(2 + i // 2)
        for i in range(k+2, n+1):
            res.append(i)
        return res
# C++
class Solution {
public:
    vector<int> constructArray(int n, int k) {
        vector<int> res;
        res.push_back(1);
        for (int i = 0; i < k; i++) {
            if (i % 2 == 0) {
                res.push_back(1 + k - i / 2);
            } else {
                res.push_back(2 + i / 2);
            }
        }
        for (int i = k + 2; i <= n; i++) {
            res.push_back(i);
        }
        return res;
    }
};
```

#### 9. æ•°ç»„çš„åº¦

[LeetCode 697. Degree of an Array (Easy)](https://leetcode.com/problems/degree-of-an-array/description/)

ä½¿ç”¨å­—å…¸ç»Ÿè®¡å‡ºç°æ¬¡æ•°ä»¥åŠå‡ºç°çš„ä½ç½®å’Œå½“å‰çš„å®½åº¦ï¼Œæœ€åè¿”å›å³å¯ã€‚

```python
# Python
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1: return 1
        myDic = {}
        maxNum, length = float('-inf'), 0
        prevItem = None
        
        for index, item in enumerate(nums):
            if item not in myDic:
                # [total times, first appear, last appear, width]
                myDic[item] = [1, index, index, 1]
            else:
                myDic[item][0] += 1
                myDic[item][2] = index
                myDic[item][3] = myDic[item][2] - myDic[item][1] + 1
                if myDic[item][0] > maxNum:
                    maxNum = myDic[item][0]
                    length = myDic[item][3]
                    prevItem = item
                elif myDic[item][0] == maxNum:
                    length = min(myDic[item][3], myDic[prevItem][3])
                    
        if maxNum == float('-inf'):
            return 1
        else:
            return length
```

#### 10. å¯¹è§’å…ƒç´ ç›¸ç­‰çš„çŸ©é˜µï¼ˆæœ¬é¢˜ä¸åŒå®ç°C++ï¼Œpythonï¼Œjavaé€Ÿåº¦ä¸åŒï¼Œè¿˜ä¸çŸ¥é“ä»€ä¹ˆåŸå› ã€‚ï¼‰

> ç›¸åŒçš„å®ç°æ–¹æ³•ï¼ŒJava 1msï¼ŒC++å´éœ€è¦30msï¼Œpythonéœ€è¦80msã€‚è¿˜æ²¡ææ¸…æ¥šä¸ºä»€ä¹ˆJavaè¿™ä¹ˆå¿«ã€‚

```python
# é€’å½’ python
class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(len(matrix[0])):
            if not self.check(matrix, matrix[0][i], 0, i):
                return False
        for i in range(len(matrix)):
            if not self.check(matrix, matrix[i][0], i, 0):
                return False
        return True
        
    def check(self, matrix, expectValue, row, col):
        if row >= len(matrix) or col >= len(matrix[0]):
            return True
        if matrix[row][col] != expectValue:
            return False
        return self.check(matrix, expectValue, row + 1, col + 1)
# Python åŒé‡å¾ªç¯
class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(len(matrix) - 1):
            for j in range(len(matrix[0]) - 1):
                if matrix[i][j] == matrix[i+1][j+1]:
                    continue
                else:
                    return False
        return True
# C++ åŒé‡å¾ªç¯
class Solution {
public:
    bool isToeplitzMatrix(vector<vector<int>>& matrix) {
        for (int i = 0; i < matrix.size() -1; i++) {
            for (int j = 0; j < matrix[0].size() -1; j++) {
                if (matrix[i][j] == matrix[i+1][j+1])
                    continue;
                else
                    return false;
            }
        }
        return true;
    }
};
# é€’å½’ï¼ŒC++
class Solution {
public:
    bool isToeplitzMatrix(vector<vector<int>>& matrix) {
        for (int i = 0; i < matrix[0].size(); i++) {
            if (!check(matrix, matrix[0][i], 0, i))
                return false;
        }
        for (int i = 0; i < matrix.size(); i++) {
            if (!check(matrix, matrix[i][0], i, 0))
                return false;
        }
        return true;
    }
    bool check(vector<vector<int>> matrix, int expectValue, int row, int col) {
        if (row >= matrix.size() || col >= matrix[0].size()) 
            return true;
        if (matrix[row][col] != expectValue)
            return false;
        return check(matrix, expectValue, row+1, col+1);
    }
};
```

#### 11. åµŒå¥—æ•°ç»„

[LeetCode 565. Array Nesting (Medium)](https://leetcode.com/problems/array-nesting/description/)

æœ¬é¢˜æ•°ç»„æœ‰ä¸€ä¸ªç‰¹ç‚¹å°±æ˜¯ï¼Œç”±äºNä¸ªä½ç½®ï¼Œå­˜å‚¨N-1ä¸ªæ•°ï¼Œä»0å¼€å§‹ï¼Œæ²¡æœ‰ä¸€ä¸ªä½ç½®çš„æ•°æ˜¯å¯ä»¥é€šè¿‡ä¸¤ä¸ªç´¢å¼•æŒ‡å‘çš„ã€‚æ¯ä¸ªç´¢å¼•éƒ½æŒ‡å‘ç‹¬ç«‹çš„æ•°ã€‚å¦‚æœå½¢æˆå¾ªç¯ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯äº’ä¸ç›¸äº¤ã€é—­åˆçš„ç¯ã€‚

æ–¹æ³•ï¼šä»å¤´éå†æ•°ç»„ï¼Œéå†è¿‡çš„ä½ç½®å€¼ä¿®æ”¹ä¸º-1. å¦‚æœé‡åˆ°-1é‚£ä¹ˆä»¥ä¸ºå½¢æˆé—­åˆï¼Œç»Ÿè®¡ä¸ªæ•°ï¼Œå¹¶é€€å‡ºã€‚éå†å®Œæ¯•ï¼Œè¿”å›æœ€å¤§å€¼å³å¯ã€‚

```python
# Python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        maxNum = 0
        for i in range(len(nums)):
            count = 0
            index = i
            while nums[index] != -1:
                count += 1
                tmp = nums[index]
                nums[index] = -1
                index = tmp
                
            maxNum = max(maxNum, count)
        return maxNum

# C++
class Solution {
public:
    int arrayNesting(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < nums.size(); i++) {
            int count = 0;
            for (int j = i; nums[j] != -1; ) {
                count++;
                int tmp = nums[j];
                nums[j] = -1;
                j = tmp;
            }
            res = max(res, count);
        }
        return res;
    }
};
```

#### 12. åˆ†éš”æ•°ç»„

[LeetCode 769. Max Chunks To Make Sorted (Medium)](https://leetcode.com/problems/max-chunks-to-make-sorted/description/)

ä¸€æ ·æ˜¯nä¸ªæ•°ï¼Œä»0åˆ°n-1. 

åˆ†æé—®é¢˜[a, b, c]ï¼Œaã€bã€cæ˜¯**æ•°ç»„çš„å‰ä¸‰ä¸ªæ•°**ã€‚å¦‚æœabcå¯ä»¥æ’åºæˆä¸€ä¸ªç”Ÿåºåºåˆ—ï¼Œé‚£ä¹ˆaã€bã€cçš„æœ€å¤§å€¼ä¸€å®šæ˜¯2ï¼›aã€bã€cä¸€å®šæ˜¯0ï¼Œ1ï¼Œ2çš„ä¸€ç§æ’åˆ—ï¼Œä¸”2åœ¨cçš„ä½ç½®ã€‚ç´¢å¼•0å’Œç´¢å¼•1çš„ä½ç½®ä¸€å®šæ˜¯1å’Œ0ï¼Œä¸ç„¶æœ€å¤§å€¼ä¸å¯èƒ½æ˜¯2ã€‚å› æ­¤åªéœ€è¦åˆ¤æ–­éå†åˆ°å½“å‰ç´¢å¼•ä½ç½®içš„æœ€å¤§å€¼æ˜¯å¦ç­‰äºiã€‚å¦‚æœç›¸ç­‰ï¼Œé‚£ä¹ˆåˆ°ç›®å‰ä½ç½®ä¸€å®šå¯ä»¥æ„æˆä¸€ä¸ªå­æ•°ç»„ã€‚

è§†é¢‘æè¿°å‚è€ƒ[èŠ±èŠ±é…±](https://www.youtube.com/watch?v=twYLu4hEKnQ)

```python
# Python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        res, right = 0, arr[0]
        
        for i in range(len(arr)):
            right = max(right, arr[i])
            if right == i: res += 1
        return res
    
# C++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int res = 0, right = arr[0];
        for (int i = 0; i < arr.size(); i++) {
            right = max(right, arr[i]);
            if (right == i)
                res++;
        }
        return res;
    }
};
```

