## 数组与矩阵

#### 1. 把数组中的0移动到末尾

[LeetCode 283. Move Zeros (Easy)](https://leetcode.com/problems/move-zeroes/description/)

设置一个索引notZeroPoint，开始指向列表的开头位置。我们遍历数组，寻找非0元素，将非0元素按顺序依次记录在索引notZeroPoint中。遍历结束后，所有的非0元素都按元顺序排列在了列表的前面。剩下将后面位置补0即可。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        notZeroPoint = 0
        
        for item in nums:
            if item != 0:
                nums[notZeroPoint] = item
                notZeroPoint += 1
                
        while notZeroPoint < len(nums):
            nums[notZeroPoint] = 0
            notZeroPoint += 1
```

#### 2. 改变矩阵维度

[LeetCode 566. Reshape the Matrix (Easy)](https://leetcode.com/problems/reshape-the-matrix/description/)

首先判断矩阵输入元素数量是否可以生成新的矩阵维度，如果不能直接返回原矩阵。接下来就双层循环，依次添加到新的列表中即可（中间设置i变量统计每行的列数。）时间复杂度为$O(m*n)$

```python
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        old_r = len(nums)
        old_c = len(nums[0])
        ret, i, temp_row = [], 0, []
        
        if old_r * old_c != r * c:
            return nums
        
        for x in nums:
            for y in x:
                temp_row.append(y)
                i += 1
                if i % c == 0:
                    ret.append(temp_row)
                    temp_row = []
        return ret
```

#### 3. 数组中最长的连续1

[LeetCode 485. Max Consecutive Ones (Easy)](https://leetcode.com/problems/max-consecutive-ones/description/)

直接遍历列表，如果遇到0直接重置当前tmpLen的长度为0.如果遇到1，那么对tmpLen进行加1操作。如果当前值比最大值要大，那么更新最大值。

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        maxLen, tmpLen = 0, 0
        
        for index in range(len(nums)):
            if nums[index] == 1:
                tmpLen += 1
                if tmpLen > maxLen: maxLen = tmpLen
            else:
                tmpLen = 0
                
        return maxLen
```

